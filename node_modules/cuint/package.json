{
  "name": "cuint",
  "version": "0.1.5",
  "description": "Unsigned integers for Javascript",
  "main": "index.js",
  "scripts": {
    "test": "mocha",
    "prepublish": "node build"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/pierrec/js-cuint"
  },
  "keywords": [
    "C",
    "unsigned",
    "integer",
    "32bits",
    "64bits"
  ],
  "author": {
    "name": "Pierre Curto"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/pierrec/js-cuint/issues"
  },
  "homepage": "https://github.com/pierrec/js-cuint",
  "devDependencies": {
    "minify": "0.2.x"
  },
  "readme": "# C-like unsigned integers for Javascript\n\n## Synopsis\n\nJavascript does not natively support handling of unsigned 32 or 64 bits integers. This library provides that functionality, following C behaviour, enabling the writing of algorithms that depend on it. It was designed with performance in mind and tries its best to be as fast as possible. Any improvement is welcome!\n\n\n## How it works\n\nAn unsigned 32 bits integer is represented by an object with its first 16 bits (low bits) and its 16 last ones (high bits). All the supported standard operations on the unsigned integer are then performed transparently.\n\n\te.g.\n\t10000010000100000100010000100010 (2182104098 or 0x82104422) is represented by:\n\thigh=1000001000010000\n\tlow= 0100010000100010\n\nNB.\nIn case of overflow, the unsigned integer is _truncated_ to its lowest 32 bits (in case of UINT32) or 64  bits (in case of UINT64).\n\nThe same applies to 64 bits integers, which are split into 4 16 bits ones.\n\n## Installation\n\nIn nodejs:\n\n    npm install cuint\n\nIn the browser, include the following (file is located in the _build_ directory), and access the constructor with _UINT32_:\n\n`<script src=\"/your/path/to/uint32.js\"></script>\n...\n<script type=\"text/javascript\">\n  var v1 = UINT32('326648991');\n  var v2 = UINT32('265443576');\n  var v1plus2 = v1.add(v2) // 592092567\n</script>`\n\n## Usage\n\nTo instantiate an unsigned 32 bits integer, do any of the following:\n\n\tvar UINT32 = require('cuint').UINT32 // NodeJS\n\tUINT32( <low bits>, <high bits> )\n\tUINT32( <number> )\n\tUINT32( '<number>', <radix> ) // radix = 10 by default\n\nTo instantiate an unsigned 64 bits integer, do any of the following:\n\n\tvar UINT64 = require('cuint').UINT64 // NodeJS\n\tUINT64( <low bits>, <high bits> )\n\tUINT64( <first low bits>, <second low bits>, <first high bits>, <second high bits> )\n\tUINT64( <number> )\n\tUINT64( '<number>', <radix> ) // radix = 10 by default\n\n## Important\n\nMost methods __do modify__ the object they are applied to. For instance, the following is equivalent to `x += y`\n\n\tUINT(x).add( UINT(y) )\n\nThis allows for chaining and reduces the cost of the emulation.\nTo have `z = x + y`, do the following:\n\n    z = UINT(x).clone().add( UINT(y) )\n\n## Examples for UINT32\n\n* Using low and high bits\n> `UINT32( 2, 1 )\t\t// 65538`\n> { remainder: null, _low: 2, _high: 1 }\n\n* Using a number (signed 32 bits integer)\n> `UINT32( 65538 ) \t// 65538`\n> { remainder: null, _low: 2, _high: 1 }\n\n* Using a string\n> `UINT32( '65538' )\t// 65538`\n> { remainder: null, _low: 2, _high: 1 }\n\n* Using another string\n> `UINT32( '3266489917' )`\n> { remainder: null, _low: 44605, _high: 49842 }\n\n* Divide 2 unsigned 32 bits integers - note that the remainder is also provided\n> `UINT32( '3266489917' ).div( UINT32( '668265263' ) )`\n> {\tremainder:\n>\t\t\t{\tremainder: null\n>\t\t\t,\t_low: 385\n>\t\t\t,\t_high: 9055\n>\t\t\t}\n>\t,\t_low: 4\n>\t,\t_high: 0\n>\t}\n\n## Examples for UINT64\n\n* Using low and high bits\n> `UINT64( 2, 1 )\t\t// 4294967298`\n> { remainder: null, _a00: 2, _a16: 0, _a32: 1, _a48: 0 }\n\n* Using first/second low and high bits\n> `UINT64( 2, 1, 0, 0 )\t\t// 65538`\n> { remainder: null, _a00: 2, _a16: 1, _a32: 0, _a48: 0 }\n\n* Using a number (signed 32 bits integer)\n> `UINT64( 65538 ) \t// 65538`\n> { remainder: null, _a00: 2, _a16: 1, _a32: 0, _a48: 0 }\n\n* Using a string\n> `UINT64( '65538' )\t// 65538`\n> { remainder: null, _a00: 2, _a16: 1, _a32: 0, _a48: 0 }\n\n* Using another string\n> `UINT64( '3266489917' )`\n> { remainder: null, _a00: 44605, _a16: 49842, _a32: 0, _a48: 0 }\n\n* Divide 2 unsigned 64 bits integers - note that the remainder is also provided\n> `UINT64( 'F00000000000', 16 ).div( UINT64( '800000000000', 16 ) )`\n> { remainder: \n>   { remainder: null,\n>     _a00: 0,\n>     _a16: 0,\n>     _a32: 28672,\n>     _a48: 0 },\n>  _a00: 1,\n>  _a16: 0,\n>  _a32: 0,\n>  _a48: 0 }\n\n## Methods\n\nMethods specific to _UINT32_ and _UINT64_:\n\n* `UINT32.fromBits(<low bits>, <high bits>)*`\nSet the current _UINT32_ object with its low and high bits\n* `UINT64.fromBits(<low bits>, <high bits>)*`\nSet the current _UINT64_ object with its low and high bits\n* `UINT64.fromBits(<first low bits>, <second low bits>, <first high bits>, <second high bits>)*`\nSet the current _UINT64_ object with all its low and high bits\n\nMethods common to _UINT32_ and _UINT64_:\n\n* `UINT.fromNumber(<number>)*`\nSet the current _UINT_ object from a number (first 32 bits only)\n* `UINT.fromString(<string>, <radix>)`\nSet the current _UINT_ object from a string\n* `UINT.toNumber()`\nConvert this _UINT_ to a number\n* `UINT.toString(<radix>)`\nConvert this _UINT_ to a string\n* `UINT.add(<uint>)*`\nAdd two _UINT_. The current _UINT_ stores the result\n* `UINT.subtract(<uint>)*`\nSubtract two _UINT_. The current _UINT_ stores the result\n* `UINT.multiply(<uint>)*`\nMultiply two _UINT_. The current _UINT_ stores the result\n* `UINT.div(<uint>)*`\nDivide two _UINT_. The current _UINT_ stores the result.\nThe remainder is made available as the _remainder_ property on the _UINT_ object.\nIt can be null, meaning there are no remainder.\n* `UINT.negate()` alias `UINT.not()`\nNegate the current _UINT_\n* `UINT.equals(<uint>)` alias `UINT.eq(<uint>)`\nEquals\n* `UINT.lessThan(<uint>)` alias `UINT.lt(<uint>)`\nLess than (strict)\n* `UINT.greaterThan(<uint>)` alias `UINT.gt(<uint>)`\nGreater than (strict)\n* `UINT.or(<uint>)*`\nBitwise OR\n* `UINT.and(<uint>)*`\nBitwise AND\n* `UINT.xor(<uint>)*`\nBitwise XOR\n* `UINT.shiftRight(<number>)*` alias `UINT.shiftr(<number>)*`\nBitwise shift right\n* `UINT.shiftLeft(<number>[, <allowOverflow>])*` alias `UINT.shiftl(<number>[, <allowOverflow>])*`\nBitwise shift left\n* `UINT.rotateLeft(<number>)*` alias `UINT.rotl(<number>)*`\nBitwise rotate left\n* `UINT.rotateRight(<number>)*` alias `UINT.rotr(<number>)*`\nBitwise rotate right\n* `UINT.clone()`\nClone the current _UINT_\n\nNB. methods with an * do __modify__ the object it is applied to. Input objects are not modified.\n\n## TODO\n\n* more methods:\n    * pow\n    * log\n    * sqrt\n    * ...\n* signed version\n\n\n## License\n\nMIT\n\n\n> Written with [StackEdit](https://stackedit.io/).",
  "readmeFilename": "README.md",
  "_id": "cuint@0.1.5",
  "_from": "cuint@latest"
}
